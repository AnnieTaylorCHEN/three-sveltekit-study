<script lang="ts">
	import { onMount } from 'svelte';
	import { browser } from '$app/env';
	import * as THREE from 'three';
	import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

	let canvasEl: HTMLElement;

	onMount(() => {
		if (browser) {
			// sizes
			const sizes = {
				width: window.innerWidth,
				height: window.innerHeight
			};

			window.addEventListener('resize', () => {
				// Update sizes
				sizes.width = window.innerWidth;
				sizes.height = window.innerHeight;

				// Update camera
				camera.aspect = sizes.width / sizes.height;
				camera.updateProjectionMatrix();

				// Update renderer
				renderer.setSize(sizes.width, sizes.height);
				renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
			});

			//scene
			const scene = new THREE.Scene();

			//objects
			const object1 = new THREE.Mesh(
				new THREE.CylinderGeometry(0.25, 0.25, 1.15, 8),
				new THREE.MeshBasicMaterial({ color: '#d8c6b0' })
			);
			// object1.material.wireframe = true;
			object1.position.x = -1.5;

			const object2 = new THREE.Mesh(
				new THREE.IcosahedronGeometry(0.5, 0),
				new THREE.MeshBasicMaterial({ color: '#d8c6b0' })
			);

			// object2.material.wireframe = true;

			const object3 = new THREE.Mesh(
				new THREE.TetrahedronGeometry(0.5, 0),
				new THREE.MeshBasicMaterial({ color: '#d8c6b0' })
			);
			// object3.material.wireframe = true;
			object3.position.x = 1.5;

			scene.add(object1, object2, object3);

			// raycaster
			let currentIntersect = null;

			// mouse
			const mouse = new THREE.Vector2();

			window.addEventListener('mousemove', (event) => {
				mouse.x = (event.clientX / sizes.width) * 2 - 1;
				mouse.y = -(event.clientY / sizes.height) * 2 + 1;
			});

			window.addEventListener('click', () => {
				if (currentIntersect) {
					switch (currentIntersect.object) {
						case object1:
							console.log('click on object 1');
							break;

						case object2:
							console.log('click on object 2');
							break;

						case object3:
							console.log('click on object 3');
							break;
					}
				}
			});

			//camera with args 75 degree, aspect ratio, minmax range
			const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 1, 1000);
			camera.position.z = 3;
			scene.add(camera);

			// renderer
			let renderer: THREE.WebGLRenderer;
			const createScene = (canvasEl) => {
				renderer = new THREE.WebGLRenderer({ canvas: canvasEl });
				renderer.setSize(sizes.width, sizes.height);
				renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 2 is usually enough, higher = expensive computing
				renderer.render(scene, camera);
			};

			createScene(canvasEl);

			//controls
			const controls = new OrbitControls(camera, canvasEl);
			controls.enableDamping = true;

			//animation
			const clock = new THREE.Clock();
			const tick = () => {
				const elapsedTime = clock.getElapsedTime();
				// Animate objects
				object1.position.y = Math.sin(elapsedTime * 0.4) * 1.2;
				object2.position.y = Math.sin(elapsedTime * 0.8) * 1.2;
				object3.position.y = Math.sin(elapsedTime * 1.2) * 1.2;

				// raycaster
				const raycaster = new THREE.Raycaster();
				const rayOrigin = new THREE.Vector3(-3, 0, 0);
				const rayDirection = new THREE.Vector3(1, 0, 0);
				rayDirection.normalize(); //Convert this vector to a unit vector - that is, sets it equal to a vector with the same direction as this one, but length 1.

				// raycaster.set(rayOrigin, rayDirection);

				// const objectsToTest = [object1, object2, object3];
				// const intersects = raycaster.intersectObjects(objectsToTest);

				// Cast a fixed ray

				// for (const object of objectsToTest) {
				// 	object.material.color.set('#be965b');
				// }

				// for (const intersect of intersects) {
				// 	// @ts-ignore
				// 	intersect.object.material.color.set('#3f4f5f');
				// }

				// Cast a ray from the mouse
				// raycaster.setFromCamera(mouse, camera);

				// for (const intersect of intersects) {
				// 	// @ts-ignore
				// 	intersect.object.material.color.set('#8da47e');
				// }

				// for (const object of objectsToTest) {
				// 	if (!intersects.find((intersect) => intersect.object === object)) {
				// 		object.material.color.set('#e9bbb5');
				// 	}
				// }

				// Cast a ray from the mouse and handle events
				raycaster.setFromCamera(mouse, camera); //2D coordinates of the mouse, in normalized device coordinates (NDC)---X and Y components should be between -1 and 1.

				const objectsToTest = [object1, object2, object3];
				const intersects = raycaster.intersectObjects(objectsToTest);

				for (const object of objectsToTest) {
					object.material.color.set('#be965b');
				}

				for (const intersect of intersects) {
					// @ts-ignore
					intersect.object.material.color.set('#3f4f5f');
				}

				if (intersects.length) {
					if (!currentIntersect) {
						console.log('mouse enter');
					}

					currentIntersect = intersects[0];
				} else {
					if (currentIntersect) {
						console.log('mouse leave');
					}

					currentIntersect = null;
				}

				//controls update
				controls.update();

				//render, call tick again on the next frame
				renderer.render(scene, camera);
				window.requestAnimationFrame(tick);
			};
			tick();
		}
	});
</script>

<section>
	<p>Hover your mouse to change color!</p>
	<canvas bind:this={canvasEl} />
</section>

<style>
	section {
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		margin: 0 auto;
	}
</style>
